## 从输入`url`到浏览器显示页面发生了什么？
### 1. 输入网址
当你开始输入网址时浏览器就可以在书签或者历史记录中去搜索相关网址推荐给你
### 2. 浏览器查找域名的`IP`地址
  1. 请求发起后，浏览器首先会解析这个域名，首先它会查看本地硬盘的`hosts`文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用`hosts`文件中的`ip`地址
  2. 如果在本地的`hosts`文件没有能够找到对应的`ip`地址，浏览器会发出一个`DNS`请求到本地`DNS`（域名分布系统）服务器。本地`DNS`服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动
  3. 查询你输入的网址的`DNS`请求到达本地`DNS`服务器之后，本地`DNS`服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地`DNS`服务器还要向`DNS`根服务器进行查询
  4. 根`DNS`服务器没有记录具体的域名和`IP`地址的对应关系，而是告诉本地`DNS`服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程
  5. 本地`DNS`服务器继续向域服务器发送请求，在这个例子中，请求的对象是`.com`域服务器。`.com`域服务器收到请求后，也不会直接返回域名和`ip`地址的对应关系，而是告诉本地`DNS`服务器，你的域名的解析服务器的地址
  6. 最后，本地`DNS`服务器向域名的解析服务器发出请求，这是就能收到一个域名和`IP`地址对应的关系，本地`DNS`服务器不仅要把`IP`地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

![img](https://images2017.cnblogs.com/blog/1171046/201712/1171046-20171226173034151-855747573.jpg)

### 3. 建立`TCP`链接
在拿到域名对应的`IP`地址后，会以随机端口（`1024-65535`）向web服务器程序`80`端口发起`TCP`的连接请求，这个连接请求进入到内核`TCP/IP`协议栈（用于识别该连接请求，解封包，一层层的剥开），还有可能要经过`Netfilter`防火墙（属于内核模块）的过滤，最终到达`web`程序，最终建立`TCP/IP`的连接，对于客户端与服务器的`TCP`链接，既【三次握手】

![img](https://img2018.cnblogs.com/blog/1171046/201904/1171046-20190409190539159-883745097.png)

客户端发送一个带有`SYN`标志的数据包给服务端，服务端收到后，回传一个带有`SYN/ACK`标志的数据包以示传达确认信息，最后客户端再回传一个带`ACK`标志的数据包，代表握手结束，连接成功。

通俗化之后就是：

客户端：老弟我要跟你链接

服务端：好的，同意了

客户端：好嘞
### 4. 浏览器向`WEB`服务器发起`Http`请求
建立`TCP`连接之后，发起`Http`请求，请求一般分为三部分

请求方法URI协议/版本

请求头(`Request Header`)

请求正文

![img](https://img-blog.csdn.net/20180519235118178?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXhzaGk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 5. 服务器端处理
服务器端收到请求后的由`web`服务器（准确说应该是`http`服务器）处理请求，诸如`Apache`、`Ngnix`、`IIS`等。`web`服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过`web`服务器返回给浏览器客户端。

![img](https://img2018.cnblogs.com/blog/1171046/201904/1171046-20190409191054591-1163748805.png)

### 6. 关闭`TCP`链接
为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建`TCP`连接的`3`次握手类似，关闭`TCP`连接，需要`4`次握手。

![img](https://img2018.cnblogs.com/blog/1171046/201904/1171046-20190409191208891-688664454.png)

客户端：老弟，我这边没数据要传了，咱们关闭链接吧

服务端：好的，接收到了，我看看我这边还有没有要传的

服务端：我这边也没有了，关闭吧

客户端：好嘞

### 7. 浏览器解析资源
对于获取到的`HTML`、`CSS`、`JS`、图片等等资源
浏览器通过解析`HTML`，生成`DOM`树，解析`CSS`，生成`CSS`规则树，然后通过`DOM`树和`CSS`规则树生成渲染树。渲染树与`DOM`树不同，渲染树中并没有`head`、`display`为`none`等不必显示的节点

在解析`CSS`的同时，可以继续加载解析`HTML`，但在解析执行`JS`脚本时，会停止解析后续`HTML`，这就会出现阻塞问题。

![img](https://user-gold-cdn.xitu.io/2018/2/22/161bb3c9b220f8cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 8. 游览器布局渲染
根据渲染树布局，计算`CSS`样式，即每个节点在页面中的大小和位置等几何信息。`HTML`默认是流式布局的，`CSS`和`js`会打破这种布局，改变`DOM`的外观样式以及大小和位置。这时就要提到两个重要概念：`repaint`和`reflow`。

* `repaint`（重绘）：屏幕的一部分重画，不影响整体布局，比如某个`CSS`的背景色变了，但元素的几何尺寸和位置不变。
* `reflow`（重排）： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是`Reflow`，或是`Layout`。

有些情况下，比如修改了元素的样式，浏览器并不会立刻 `reflow` 或 `repaint` 一次，而是会把这样的操作积攒一批，然后做一次 `reflow`，这又叫异步 `reflow` 或增量异步 `reflow`。
有些情况下，比如 `resize` 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 `reflow`。

### 9. 重绘和回流其实也和 `Eventloop` 有关。

* 当 `Eventloop` 执行完 `Microtasks` 后，会判断 `document` 是否需要更新，因为浏览器是 `60Hz` 的刷新率，每 `16.6ms` 才会更新一次。
* 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 `16ms` 才会触发一次，并且自带节流功能。
* 判断是否触发了 `media query`
* 更新动画并且发送事件
* 判断是否有全屏操作事件
* 执行 `requestAnimationFrame`回调
* 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面
* 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback`回调

### 10. 如何减少重绘和回流：

* 使用 `transform` 替代 `top`
* 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
* 不要把节点的属性值放在一个循环里当成循环里的变量
* 不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局
* 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`
* `CSS` 选择符从右往左匹配查找，避免节点层级过多
* 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 `video` 标签来说，浏览器会自动将该节点变为图层。
* 避免使用`css`表达式(`expression`)，因为每次调用都会重新计算值（包括加载页面）
* 尽量使用 `css` 属性简写，如：用 `border` 代替 `border-width`, `border-style`, `border-color`
* 批量修改元素样式：`elem.className` 和 `elem.style.cssText` 代替 `elem.style.xxx`
* 需要要对元素进行复杂的操作时，可以先隐藏(`display:"none"`)，操作完成后再显示
* 需要创建多个`DOM`节点时，使用`DocumentFragment`创建完后一次性的加入`document`
* 缓存`Layout`属性值，如：`var left = elem.offsetLeft`; 这样，多次使用 `left` 只产生一次回流

  #### 设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层
  * `will-change`
  * `video、iframe 标签`
