### 图是什么？
* 图是网络结构的抽象模型，是一组由边连接的节点
* 图可以表示任何二元关系，比如道路、航班。
* JS中没有图，但是可以用Object和Array构建图
* 图的表示法：邻接矩阵，邻接表，关联矩阵

  ![邻接矩阵](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1910418913,361191285&fm=15&gp=0.jpg)

  ```
  {
    "V1"：["V2", "V3", "V4"],
    "V2": [],
    "V3": ["V4"],
    "V4": ["V1"]
  }
  ```

### 图的常用操作
* 深度优先遍历：尽可能深的搜索图的分支
* 广度优先遍历：先访问离根节点最近的节点

### 图的深度优先遍历的算法口诀
* 访问根节点
* 对根节点的没访问过的相邻节点挨个进行深度优先遍历

### 图的广度优先遍历的算法口诀
* 新建一个队列，把根节点入队
* 把队头出队并访问
* 把队头的没访问过的相邻节点入队
* 重复第二三步，直到队列为空

```JavaScript
// graph.js
const graph ={
  0: [1, 2],
  1: [2],
  2: [0, 3],
  3: [3]
}
module.exports = graph;
```

```JavaScript
// 图的深度优先遍历实现
const graph= require('./graph');
// 用来记录已访问过的节点
const visited = new Set();
const dfs = (n)=>{
  console.log(n);
  visited.add(n);
  graph[n].forEach(c => { // 拿到所有相邻节点
    if(!visited.has(c)){ // 还未访问过的相邻接点
      dfs(c);
    }
  });
};
dfs(2);
```

```JavaScript
// 图的广度优先遍历实现
const graph = require('./graph')
const visited = new Set();
visited.add(2);
const queue = [2];
while(queue.length){
  const n = queue.shift();
  console.log(n);
  graph[n].forEach(c => {
    if(!visited.has(c)){
      queue.push(c);
      visited.add(c);
    }
  });
}
```

### LeetCode #65 有效的数组（缺失）

### LeetCode #417 太平洋大西洋水流问题
给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

提示：

* 输出坐标的顺序不重要
* m 和 n 都小于150
 
示例：

给定下面的 5x5 矩阵:
```
  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋
```
* 返回：[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).

解题思路：
1. 把矩阵想象成图（有向图）
2. 从海岸线逆流而上遍历图，所到之处就是可以流到某个大洋的坐标

解题步骤：
1. 新建两个矩阵，分别记录能流到两个大洋的坐标
2. 从海岸线，多管齐下，同时深度优先遍历图，过程中填充上边的那个矩阵
3. 遍历两个矩阵，找出能流到两个大洋的坐标

复杂度：
1. 时间复杂度O（m * n）
2. 空间复杂度O（m * n）

```JavaScript
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var pacificAtlantic = function(matrix) {
    if(!matrix || !matrix[0]){
        return [];
    }
    const m = matrix.length;
    const n = matrix[0].length;
    // 构建数组的两种方法1. Array.from({length:n}) 2. new Array(n)
    const flow1 = Array.from({length: m}, ()=> {return new Array(n).fill(false)});  // 能流到太平洋的矩阵
    const flow2 = Array.from({length: m}, ()=> {return new Array(n).fill(false)}); // 能流到大西洋的矩阵
    const dfs = (row, cow, flow)=>{ // 行，列
        flow[row][cow] = true;
        [[row-1, cow], [row+1, cow], [row, cow-1], [row, cow+1]].forEach(([nextrow, nextcow])=>{ 
          // 相邻的上，下，左，右四个节点的数组遍历
            if(
                //保证下一个节点在矩阵中
                nextrow >= 0 && nextrow < m  &&
                nextcow >= 0 && nextcow < n  &&
                // 防止死循环，即保证未访问过该节点
                !flow[nextrow][nextcow] && 
                // 保证逆流而上
                matrix[nextrow][nextcow] >= matrix[row][cow]
            ){ 
                dfs(nextrow, nextcow, flow)
            }
        })
    };
    // 沿着海岸线逆流而上
    for(let row=0; row<m; row++){
        dfs(row, 0 ,flow1); // 从第一行到最后一行，保证第一列，流到太平洋
        dfs(row, n-1, flow2); // 遍历最后一列的格子，流到大西洋 传flow2
    }
    for(let cow=0; cow<n; cow++){
        dfs(0, cow, flow1); // 遍历第一行，太平洋
        dfs(m-1, cow, flow2); // 遍历最后一行，大西洋
    }
    // 收集能流到两个大洋的坐标
    const res = [];
    for(let row=0; row<m; row++){ // 遍历所有行
        for(let cow=0; cow<n; cow++){ // 遍历所有列
            if(
                flow1[row][cow] && // 能流到太平洋
                flow2[row][cow] // 能流到大西洋
            ){
                res.push([row,cow])
            }
        }
    }
    
    // console.log(flow1)
    // console.log(flow2)
    return res;
};
```