## 21. 下一个排列 (`next-permutation`)

[LeetCode传送门](https://leetcode-cn.com/problems/next-permutation/)

### 题目大意：
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许使用额外常数空间。

简单来说所谓下一个排列结果其实是这些数排列组合后变成的整数。比如`[1, 2, 3]` 有排列
```JavaScript
[1, 2, 3] < [1, 3, 2] < [2, 1, 3] < [2, 3, 1] < [3, 1, 2] < [3, 2, 1]
 123 < 132 < 213 < 231 < 312 < 321
```
下一个排列就是这个顺序的下一个是那个，如果已经最大就回到队首变成最小的。

### 基本思路
1. 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的大数与前面的小数交换，就能得到一个更大的数。比如 `213`，将 `1` 和 `3` 交换就能得到一个更大的数 `231`。
2. 我们还希望下一个数增加的幅度尽可能的小，为了满足这个要求，我们需要：在尽可能靠右的低位进行交换，需要从后向前查找将一个尽可能小的大数 与前面的小数交换。比如 `1243`，下一个排列应该把 `3` 和 `2` 交换而不是把 `4`和 `2` 交换。将大数换到前面后，需要将大数后面的所有数重置为升序，升序排列就是最小的排列。
3. 已经是最大的了，是个降序(最大)，直接逆置变成升序(最小)。

### 步骤
1. 从后向前查找第一个相邻升序的元素对 `(i, j)`，满足 `A[i] < A[j]`。此时 `[j,end)` 必然是降序，如果找不到符合的相邻元素对，说明当前 `[begin, end)` 为一个降序顺序，则直接跳到步骤 4
2. 在 `[j,end)` 从后向前查找第一个满足 `A[i] < A[k]` 的 `k`。`A[i]、A[k]` 分别就是上文所说的小数、大数
3. 将 `A[i]` 与 `A[k]` 交换
4. 可以断定这时 `[j, end)` 必然是降序，逆置 `[j, end)`，使其升序

### 写法实现
```JavaScript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
  let len = nums.length
  if (len <= 1) {
    return nums
  }
  let [i, j, k] = [len - 2, len - 1, len - 1]
  // 找到第一组相邻升序
  while (i >= 0 && nums[i] >= nums[j]) {
    i--;
    j--;
  }
  // 不是最后一个排列，寻找k，使得A[i]<A[k]
  if (i >= 0) {
    while (nums[i] >= nums[k]) {
      k--;
    }
    // 解构赋值交换 A[i], A[k]
    [nums[i], nums[k]] = [nums[k], nums[i]]
  } 
  // [j, end)转升序，使数变小
  for (i = j, j = len - 1; i < j; i++, j--) {
    [nums[i], nums[j]] = [nums[j], nums[i]]
  }
  // console.log(nums)
};

console.log(nextPermutation([3,2,1]))
```