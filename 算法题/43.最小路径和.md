## 43. 最小路径和 (`minimum-path-sum`)

### 标签
* 动态规划
* 中等

### 题目
[LeetCode传送门](https://leetcode-cn.com/problems/minimum-path-sum/)

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例1：

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

* 输入：`grid = [[1,3,1],[1,5,1],[4,2,1]]`
* 输出：`7`
* 解释：因为路径 `1→3→1→1→1` 的总和最小。

示例2：
* 输入：`grid = [[1,2,3],[4,5,6]]`
* 输出：`12`

### 相关知识
从动态规划这篇我们了解到动态规划的基本步骤是下面三步：
1. 寻找最优子结构(状态表示)
2. 归纳状态转移方程(状态计算)
3. 边界初始化

### 基本步骤
接下来我们看下面具体问题
1. 状态表示:
    * `dp(i, j)` 表示从左上角出发到 `(i, j)` 位置的最小路径和。
2. 状态转移方程:
    * 由于我们每一步只能向下或向右移动一步，那么其实只有从`(i-1, j)`或者`(i, j-1)`这两处走过来，那么转移方程也很简单 `dp[i][j] = min(grid[i-1][j]`, `grid[i][j-1])`，表示每条路径取较小的来路进行加和
3. 边界初始化:
    * 那么下面就是定边界，我们知道最上面一排和最左边一排，只有一种可能来的路径，最顶时，来的路只有从左边`1`条，最左边来的路只有从上面`1`条。所以说，`i = 0`或`j = 0`时，直接进行来路加和就行，不用比较大小，因为只有一条。

### 写法实现
```JavaScript
var minPathSum = function(grid) {
  let [row, col] = [grid.length, grid[0].length]
  // 可以直接在原来的数组中做原地 DP，不用额外空间
  // 跟上题类似，把边界先加和，左边只能从上走，上边只能从左走
  for (i = 1; i < row; i++) {
    grid[i][0] += grid[i-1][0]
  }
  for (j = 1; j < col; j++) {
    grid[0][j] += grid[0][j-1]
  }
  // 把剩下的非边界位置用递推公式补齐，据题意取来路较小路径的就行
  for (i = 1; i < row; i++) {
    for (j = 1; j < col; j++) {
      grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1])
    }
  }
  return grid[row-1][col-1]
};

let grid = [[1,3,1],[1,5,1],[4,2,1]]
console.log(minPathSum(grid))

```