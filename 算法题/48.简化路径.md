## 48. 简化路径 (`simplify-path`)

### 标签
* 栈
* 文字理解
* 中等

### 题目
[LeetCode传送门](https://leetcode-cn.com/problems/simplify-path/)

给你一个字符串 `path` ，表示指向某一文件或目录的 `Unix` 风格 绝对路径 （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。

在 `Unix` 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'`）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如，`'...'`）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：

始终以斜杠 `'/'` 开头。
两个目录名之间必须只有一个斜杠 `'/'` 。
最后一个目录名（如果存在）不能 以 `'/'` 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。
返回简化后得到的 规范路径 。

示例 1：
* 输入：`path = "/home/"`
* 输出：`"/home"`
* 解释：注意，最后一个目录名后面没有斜杠。 

示例 2：
* 输入：`path = "/../"`
* 输出：`"/"`
* 解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。

示例 3：
* 输入：`path = "/home//foo/"`
* 输出：`"/home/foo"`
* 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。

示例 4：
* 输入：`path = "/a/./b/../../c/"`
* 输出：`"/c"`
 

提示：

* `1 <= path.length <= 3000`
* `path` 由英文字母，数字，`'.'`，`'/'` 或 `'_'` 组成。
* `path` 是一个有效的 `Unix` 风格绝对路径。

### 基本思路
思考一个问题 `..`是回退上一级，一般目录层级只有两个数据结构，一个是树，一个是栈。新建一个栈`stack`为当前的路径。并将`path`以`'/'`分割成数组，两个`/`连续的中间是空字符串。遍历，并根据题意处理这些边界条件即可。

### 基本步骤
1. 先把 path 用 / 进行分割成数组。结果含有以下几种情况
    * `''`
    * `'pathName'`
    * `'/'`
    * `'.'`
    * `'..'`
2. 分情况处理

    * 遇到 `.` 或者为`''`时，不修改当前 `stack`。
    * 遇到`pathName`时，推入 `stack` 中
    * 遇到 `..` 时，`stack` 栈顶元素出栈，回退到上一个路径
3. 这样，遍历结束，返回 `'/' + stack.join('/')` 就会变成一个标准路径

### 写法实现
```JavaScript
var simplifyPath = function(path){
  const stack = []
  const pathArr = path.split('/')
  pathArr.map(item=>{
    if(item === '' || item === '.'){

    }else if(item === '..'){
      stack.pop();
    }else{
      stack.push(item)
    }
  })
  return '/' + stack.join('/')
}
console.log(simplifyPath('/home/'))
```


