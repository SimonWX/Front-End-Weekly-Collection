### 盛最多水的容器 (`container-with-most-water`)
[LeetCode传送门](https://leetcode-cn.com/problems/container-with-most-water/)

题目大意：给出一个非负整数数组 a1，a2，a3，…… an，每个整数标识一个竖立在坐标轴 x 位置的一堵高度为 ai 的墙，选择两堵墙，和 x 轴构成的容器可以容纳最多的水。

基本知识
对撞指针的思路。
首尾分别 2 个指针，每次移动以后都分别判断长宽的乘积是否最大。
基本思路

1. 在初始时，左右指针分别指向数组的左右两端, 容纳的水量是由 两个指针指向的数字中较小值 x 指针之间的距离
2. 每次比较面积之后，我们移动数字较小的那个指针，直到左右指针指向一处，中途得到的最大值就是结果。

```JavaScript
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  // 解构赋值声明方式
  let [maxNow, start, end] = [0, 0, height.length - 1]
  while (start < end) {
    // 设置宽高 宽度是（结束位置 - 开始位置） 高度是 长/宽 中小的那个
    let width = end - start
    let high = 0
    // 选取后指针移动
    if (height[start] < height[end]) {
      high = height[start]
      start++
    } else {
      high = height[end]
      end--
    }
    if (maxNow < high * width) {
      maxNow = high * width 
    }
  }
  return maxNow
};

console.log(maxArea([1,8,6,2,5,4,8,3,7]))

```

### 双指针正确性验证
#### 双指针代表了什么？
双指针代表的是可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将对应的数字较小的那个指针往另一个指针的方向移动一个位置，就表示我们认为这个指针不可能再作为容器的边界了。

那么为什么对应的数字较小的那个指针不可能再作为容器的边界了？

考虑第一步，假设当前左指针和右指针指向的数分别为 x 和 y，不失一般性，我们假设 x≤y。同时，两个指针之间的距离为 t。那么，它们组成的容器的容量为：min(x, y) * t = x * t

我们可以断定，如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 x * t 了。因为取决于短板 x，宽减少，面积必然变小。也就是我们任意向左移动右指针，指向的数为y1，两个指针之间的距离为 t1，那么显然有 t1 < t
并且 min(x,y1) ≤ min(x,y)

即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。

这样以来，我们将问题的规模减小了，被我们丢弃的那个位置就相当于消失了。此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界，因此，我们可以继续像之前（考虑第一步）那样考虑这个问题。

